/*
 Navicat Premium Data Transfer

 Source Server         : localhostMysql
 Source Server Type    : MySQL
 Source Server Version : 50726
 Source Host           : localhost:3306
 Source Schema         : es_blog

 Target Server Type    : MySQL
 Target Server Version : 50726
 File Encoding         : 65001

 Date: 02/05/2020 23:51:40
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '博客表自增ID',
  `title` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '博客标题',
  `author` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '博客作者',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '博客内容',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 14 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (1, '数据结构', '啥事', '数据结构包括线性表，哈希表，图，树，二叉树，平衡树，红黑树，B树等等', '2020-05-01 10:41:03', '2020-05-01 10:41:03');
INSERT INTO `t_article` VALUES (2, 'HashMap数据结构', '三石', '# HashMap数据结构\r\n\r\n```java\r\nstatic class Node<K,V> implements Map.Entry<K,V> {\r\n        final int hash;\r\n        final K key;\r\n        V value;\r\n        Node<K,V> next;\r\n\r\n        Node(int hash, K key, V value, Node<K,V> next) {\r\n            this.hash = hash;\r\n            this.key = key;\r\n            this.value = value;\r\n            this.next = next;\r\n        }\r\n    	...\r\n}\r\n```\r\n\r\n##### 数据结构：\r\n\r\nJava中的HashMap为上述Node对象的数组结构，每个Node可以形成一个链表。\r\n\r\n\r\n\r\n```java\r\n//返回大于cap的最小的2的次方数\r\nstatic final int tableSizeFor(int cap) {\r\n        int n = cap - 1;\r\n        n |= n >>> 1;\r\n        n |= n >>> 2;\r\n        n |= n >>> 4;\r\n        n |= n >>> 8;\r\n        n |= n >>> 16;\r\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\r\n    }\r\n```\r\n\r\n上述函数用于确定HashMap的容量。\r\n\r\n\r\n\r\n```java\r\nstatic final int hash(Object key) {\r\n        int h;\r\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\r\n}\r\n/**\r\n如果hash值很大，但是HashMap容量很小，那么计算位置的时候只使用了hash值的低位与容量掩码进行与操\r\n作，高位没有用到，不利于散列度。\r\n\r\nn - 1 = 0000 1111;\r\nhash =  0101 1010\r\n(hash >>> 4) =  0000 0101\r\n\r\n则hash ^ (hash >>> 4)  = \r\n	0101 1010\r\n\r\n^   0000 0101\r\n将hash值右移四位，将其所有位都用到，可以提高散列度。\r\n**/\r\n```\r\n\r\n计算hash值，h ^ (h >>> 16)操作的目的是将h的哈希值的高位和低位都用到，用于提高散列性。\r\n\r\n', '2020-05-01 10:41:26', '2020-05-01 10:41:26');
INSERT INTO `t_article` VALUES (3, 'Spring Boot + Elastic Search + rest high level客户端', '三石', '# Spring Boot + Elastic Search + rest high level客户端\r\n\r\n### 1、maven依赖\r\n\r\n根据自己的Elastic Search版本选择elasticsearch-rest-high-level-client的版本，过高和过低都可能导致异常，我这里Elastic Search 版本为6.0.0，因为spring-data-elasticsearch中依赖的rest high level客户端版本不匹配，故而将其剔除，并重新依赖合适的版本。\r\n\r\n```xml\r\n        <dependency>\r\n            <groupId>org.springframework.data</groupId>\r\n            <artifactId>spring-data-elasticsearch</artifactId>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.elasticsearch.client</groupId>\r\n                    <artifactId>elasticsearch-rest-high-level-client</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.elasticsearch.client</groupId>\r\n            <artifactId>elasticsearch-rest-high-level-client</artifactId>\r\n            <version>6.5.4</version>\r\n        </dependency>\r\n```\r\n\r\n\r\n\r\n### 2、客户端配置Bean\r\n\r\n​		根据自己的需要配置 rest high level客户端，更多配置请参照官网文档 https://docs.spring.io/spring-data/elasticsearch/docs/3.2.7.RELEASE/reference/html/#elasticsearch.clients.configuration\r\n\r\n```java\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.elasticsearch.client.ClientConfiguration;\r\nimport org.springframework.data.elasticsearch.client.RestClients;\r\n\r\n@Configuration\r\npublic class ElasticSearchConfig {\r\n\r\n    @Bean\r\n    public RestHighLevelClient restHighLevelClient() {\r\n        ClientConfiguration configuration = ClientConfiguration.builder()\r\n                .connectedTo(\"localhost:9200\")\r\n                .build();\r\n        return RestClients.create(configuration).rest();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 3、测试\r\n\r\n​	对Elastic Search进行测试，看是否能够连通，客户端API是否可以连通。（只是简单的测试，所以一些方面没有遵循测试原则）\r\n\r\n```java\r\nimport org.elasticsearch.action.get.GetRequest;\r\nimport org.elasticsearch.action.get.GetResponse;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.test.context.junit4.SpringRunner;\r\n\r\nimport java.io.IOException;\r\nimport java.util.Map;\r\n\r\n@RunWith(SpringRunner.class)\r\n@SpringBootTest\r\npublic class TestElasticSearch {\r\n    \r\n    @Autowired\r\n    private RestHighLevelClient restHighLevelClient;\r\n    \r\n    @Test\r\n    public void testGetMethods() {\r\n        GetRequest request = new GetRequest(\"megacorp\", \"employee\", \"1\");\r\n        try {\r\n            GetResponse response = restHighLevelClient.get(request);\r\n            Map<String, Object> resource = response.getSource();\r\n            for (Map.Entry<String, Object> entry : resource.entrySet()) {\r\n                System.out.println(entry.getKey());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testSearch() {\r\n        SearchSourceBuilder builder = new SearchSourceBuilder();\r\n        builder.query(QueryBuilders.termQuery(\"about\", \"rock\"));\r\n        SearchRequest request = new SearchRequest()\r\n                .indices(\"megacorp\")\r\n                .source(builder);\r\n        try {\r\n            SearchResponse response = restHighLevelClient.search(request);\r\n            SearchHits hits = response.getHits();\r\n            for (SearchHit hit : hits.getHits()) {\r\n                Map<String, Object> map = hit.getSourceAsMap();\r\n                for (Map.Entry<String, Object> entry : map.entrySet()) {\r\n                    System.out.println(entry.getKey());\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 4、可能出现的问题\r\n\r\n​	1) 客户端版本过低可能到时的问题，可能主要是Request类中的一个init方法不存在，调用导致的问题，切换较高版本的客户端可以解决。\r\n\r\n```java\r\njava.lang.NoSuchMethodError: org.elasticsearch.client.Request.<init>(Ljava/lang/String;Ljava/lang/String;)V\r\n\r\n	at org.elasticsearch.client.RestClient.performRequest(RestClient.java:323)\r\n	at org.elasticsearch.client.RestHighLevelClient.performRequest(RestHighLevelClient.java:428)\r\n	at org.elasticsearch.client.RestHighLevelClient.performRequestAndParseEntity(RestHighLevelClient.java:414)\r\n	at org.elasticsearch.client.RestHighLevelClient.search(RestHighLevelClient.java:355)\r\n	at com.sanshi.searchforblog.testRestHighLevelAPI.testGet.testSearch(testGet.java:50)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n	at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)\r\n	at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)\r\n	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)\r\n	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)\r\n	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)\r\n	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\r\n	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)\r\n	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)\r\n	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\r\n	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\r\n	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\r\n	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\r\n	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\r\n	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\r\n	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)\r\n	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\r\n	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)\r\n	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\r\n	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\r\n	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\r\n	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\r\n	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\r\n\r\n```\r\n\r\n​	\r\n\r\n​	2)  客户端版本过高导致的问题，可能是由于客户端发送的请求中存在elastic search服务器无法识别的变量，降低 rest high level 客户端版本可以解决。\r\n\r\n```java\r\nElasticsearchStatusException[Elasticsearch exception [type=illegal_argument_exception, reason=request [/megacorp/_search] contains unrecognized parameters: [ignore_throttled], [rest_total_hits_as_int]]\r\n]\r\n	at org.elasticsearch.rest.BytesRestResponse.errorFromXContent(BytesRestResponse.java:177)\r\n	at org.elasticsearch.client.RestHighLevelClient.parseEntity(RestHighLevelClient.java:2053)\r\n	at org.elasticsearch.client.RestHighLevelClient.parseResponseException(RestHighLevelClient.java:2030)\r\n	at org.elasticsearch.client.RestHighLevelClient.internalPerformRequest(RestHighLevelClient.java:1777)\r\n	at org.elasticsearch.client.RestHighLevelClient.performRequest(RestHighLevelClient.java:1734)\r\n	at org.elasticsearch.client.RestHighLevelClient.performRequest(RestHighLevelClient.java:1717)\r\n	at org.elasticsearch.client.RestHighLevelClient.performRequestAndParseEntity(RestHighLevelClient.java:1683)\r\n	at org.elasticsearch.client.RestHighLevelClient.search(RestHighLevelClient.java:1108)\r\n	at com.sanshi.searchforblog.testRestHighLevelAPI.testGet.testSearch(testGet.java:50)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n	at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)\r\n	at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)\r\n	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)\r\n	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)\r\n	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)\r\n	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\r\n	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)\r\n	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)\r\n	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\r\n	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\r\n	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\r\n	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\r\n	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\r\n	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\r\n	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)\r\n	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\r\n	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)\r\n	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\r\n	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\r\n	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\r\n	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\r\n	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\r\n	Suppressed: org.elasticsearch.client.ResponseException: method [POST], host [http://localhost:9200], URI [/megacorp/_search?rest_total_hits_as_int=true&typed_keys=true&ignore_unavailable=false&expand_wildcards=open&allow_no_indices=true&ignore_throttled=true&search_type=query_then_fetch&batched_reduce_size=512], status line [HTTP/1.1 400 Bad Request]\r\n{\"error\":{\"root_cause\":[{\"type\":\"illegal_argument_exception\",\"reason\":\"request [/megacorp/_search] contains unrecognized parameters: [ignore_throttled], [rest_total_hits_as_int]\"}],\"type\":\"illegal_argument_exception\",\"reason\":\"request [/megacorp/_search] contains unrecognized parameters: [ignore_throttled], [rest_total_hits_as_int]\"},\"status\":400}\r\n		at org.elasticsearch.client.RestClient$SyncResponseListener.get(RestClient.java:936)\r\n		at org.elasticsearch.client.RestClient.performRequest(RestClient.java:233)\r\n		at org.elasticsearch.client.RestHighLevelClient.internalPerformRequest(RestHighLevelClient.java:1764)\r\n		... 35 more\r\n	Caused by: org.elasticsearch.client.ResponseException: method [POST], host [http://localhost:9200], URI [/megacorp/_search?rest_total_hits_as_int=true&typed_keys=true&ignore_unavailable=false&expand_wildcards=open&allow_no_indices=true&ignore_throttled=true&search_type=query_then_fetch&batched_reduce_size=512], status line [HTTP/1.1 400 Bad Request]\r\n{\"error\":{\"root_cause\":[{\"type\":\"illegal_argument_exception\",\"reason\":\"request [/megacorp/_search] contains unrecognized parameters: [ignore_throttled], [rest_total_hits_as_int]\"}],\"type\":\"illegal_argument_exception\",\"reason\":\"request [/megacorp/_search] contains unrecognized parameters: [ignore_throttled], [rest_total_hits_as_int]\"},\"status\":400}\r\n		at org.elasticsearch.client.RestClient$1.completed(RestClient.java:552)\r\n		at org.elasticsearch.client.RestClient$1.completed(RestClient.java:537)\r\n		at org.apache.http.concurrent.BasicFuture.completed(BasicFuture.java:122)\r\n		at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.responseCompleted(DefaultClientExchangeHandlerImpl.java:181)\r\n		at org.apache.http.nio.protocol.HttpAsyncRequestExecutor.processResponse(HttpAsyncRequestExecutor.java:448)\r\n		at org.apache.http.nio.protocol.HttpAsyncRequestExecutor.inputReady(HttpAsyncRequestExecutor.java:338)\r\n		at org.apache.http.impl.nio.DefaultNHttpClientConnection.consumeInput(DefaultNHttpClientConnection.java:265)\r\n		at org.apache.http.impl.nio.client.InternalIODispatch.onInputReady(InternalIODispatch.java:81)\r\n		at org.apache.http.impl.nio.client.InternalIODispatch.onInputReady(InternalIODispatch.java:39)\r\n		at org.apache.http.impl.nio.reactor.AbstractIODispatch.inputReady(AbstractIODispatch.java:114)\r\n		at org.apache.http.impl.nio.reactor.BaseIOReactor.readable(BaseIOReactor.java:162)\r\n		at org.apache.http.impl.nio.reactor.AbstractIOReactor.processEvent(AbstractIOReactor.java:337)\r\n		at org.apache.http.impl.nio.reactor.AbstractIOReactor.processEvents(AbstractIOReactor.java:315)\r\n		at org.apache.http.impl.nio.reactor.AbstractIOReactor.execute(AbstractIOReactor.java:276)\r\n		at org.apache.http.impl.nio.reactor.BaseIOReactor.execute(BaseIOReactor.java:104)\r\n		at org.apache.http.impl.nio.reactor.AbstractMultiworkerIOReactor$Worker.run(AbstractMultiworkerIOReactor.java:591)\r\n		at java.lang.Thread.run(Thread.java:748)\r\n```\r\n\r\n', '2020-05-01 10:42:05', '2020-05-01 10:42:05');
INSERT INTO `t_article` VALUES (4, '日本AV女优', '三石', '波多野结衣\r\n吉泽明步\r\n天海翼\r\n樱井莉亚\r\n苍井空\r\n大桥未久\r\n小川阿佐美\r\n早乙女露依\r\n京香julia\r\n椎名由奈\r\n冬月枫\r\n麻生希\r\n濑亚美莉\r\n立花里子\r\n松岛枫\r\n芦名未帆\r\n石川铃华\r\n水莱丽\r\n上原结衣\r\n爱乃娜美\r\n小泽玛利亚\r\n白咲舞\r\n石川施恩惠\r\n美竹凉子\r\n宇都宫紫苑\r\n北川杏树\r\n春咲梓美\r\n冲田杏梨\r\n泷泽萝拉\r\n早川濑里奈\r\n希崎杰西卡\r\n北条麻妃\r\n成濑心美\r\n上原加绘罗\r\n桃谷绘里香\r\n原更纱', '2020-05-01 13:59:02', '2020-05-01 13:59:02');
INSERT INTO `t_article` VALUES (5, 'Redis数据结构', '数据', '### SDS(Simple Dynamic String 简单动态字符串)\r\n\r\n```c\r\nstruct sdshdr{\r\n    //记录buf数组已使用的字节的数量\r\n    //等于SDS所保存字符串的长度\r\n    int len;\r\n    \r\n    //记录buf数组中未使用的字节数量\r\n    int free;\r\n    \r\n    //字节数组，用于保存字符串\r\n    char buf[];\r\n}\r\n相比于C字符串，SDS具有以下优点：\r\n1.常数复杂度获取字符串长度\r\n2.杜绝缓冲区溢出\r\n3.减少修改字符串长度所需的内存重分配次数\r\n4.二进制安全\r\n5.兼容部分C字符串函数\r\n```\r\n\r\n\r\n\r\n### 链表\r\n\r\n```c\r\ntypedef struct listNode {\r\n    //前置节点\r\n    struct listNode *prev;\r\n    \r\n    //后置节点\r\n    struct listNode *next;\r\n    \r\n    //节点的值\r\n    void *value;\r\n} listNode;\r\n```\r\n\r\n```c\r\ntypedef struct list {\r\n    //表头节点\r\n    listNode *head;\r\n    \r\n    //表尾节点\r\n    listNode *tail;\r\n    \r\n    //链表所包含的节点个数\r\n	unsigned long len;\r\n    \r\n    //节点值复制函数\r\n    void *(*dup)(void *ptr);\r\n    \r\n    //节点值释放函数\r\n    void *(*dup)(void *ptr);\r\n    \r\n    //节点值对比函数\r\n    void (*match)(void *ptr, void *key);\r\n} list;\r\n\r\nRedis链表实现的特点可以总结如下：\r\n	1.双端:链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都为O(1)\r\n    2.无环:表头prev和表尾next都指向NULL，对链表的访问以NULL为重点\r\n    3.带表头指针和表尾指针:list中的head和tail\r\n    4.带链表长度计数器:使用list结构中的len属性对持有的链表节点进行计数\r\n    5.多态:链表节点使用void*指针保存节点值，并且可以通过list结构中的dup，free，match三个属性为节点值设置类型特定函数，所以链表可用于保存各种不同类型的值。\r\n    \r\nRedis中的链表被广泛用于实现Redis的各种功能，比如列表建、发布与订阅、慢查询、监视器等。\r\n```\r\n\r\n\r\n\r\n### 字典\r\n\r\n```c\r\n//哈希表\r\ntypedef struct dictht {\r\n    //哈希表数组\r\n    dictEntry **table;\r\n    \r\n    //哈希表大小\r\n    unsigned long size;\r\n    \r\n    //哈希表大小掩码，用于计算索引值，总是等于size - 1\r\n    unsigned long sizemask;\r\n    \r\n    //该哈希表已有节点的数量\r\n    unsigned long used;\r\n} dictht;\r\ntable属性是一个数组，数组中的每一个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存一个键值对。\r\n```\r\n\r\n```c\r\n//哈希表节点\r\ntypedef struct dicEntry {\r\n    //键\r\n    void *key;\r\n    \r\n    //值\r\n    union {\r\n        void *val;\r\n        uint64_t u64;\r\n        int64_t s64;\r\n    } v;\r\n    //指向下个哈希表节点，形成链表\r\n    struct dictEntry *next;\r\n} dictEntry;\r\n\r\nkey 属性保存着键值对中的键。\r\nv 属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。\r\nnext 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突的问题。\r\n```\r\n\r\n![1573205978028](C:\\Users\\sanshi\\AppData\\Roaming\\Typora\\typora-user-images\\1573205978028.png)\r\n\r\n```c\r\n//字典\r\ntypedef struct dict {\r\n    //类型特定函数\r\n    dictType *type;\r\n    \r\n    //私有数据\r\n    void *privdata;\r\n    \r\n    //哈希表\r\n    dictht ht[2];\r\n    \r\n    //rehash索引\r\n    //当rehash不再进行时，值为-1\r\n    int trehashidx;\r\n} dict;\r\n\r\ntype 属性和 privdata 属性是针对不同类型的键值对，为创建多态字典而设置的:\r\n	1.type 属性是指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。\r\n        typedef struct dictType {\r\n        //计算哈希值的函数\r\n            unsigned int (*hashFunction)(const void *key);\r\n\r\n            //复制键的函数\r\n            void *(*keyDup)(void *privdata, const void *key);\r\n\r\n            //复制值的函数\r\n            void *(*valDup)(void *privdata, const void *obj);\r\n\r\n            //对比键的函数\r\n            void *(*keyCompare)(void *privdata, const void *key, const 															void *key2);\r\n\r\n            //销毁键的函数\r\n            void (*keyDestructor)(void *privdata, void *key);\r\n\r\n            //销毁值的函数\r\n            void (*valDestructor)(void *privdata, void *obj);\r\n        } dictType;\r\n	2.privdata 属性则保存了需要传给那些类型特定函数的可选参数。\r\n	3.ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]的哈希表，ht[1]哈希表只会对ht[0]进行rehash时使用。\r\n	4.rehashidx，它记录了rehash目前的进度，如果目前没有进行rehash，那么它的值为-1。\r\n```\r\n\r\n![1573212609849](C:\\Users\\sanshi\\AppData\\Roaming\\Typora\\typora-user-images\\1573212609849.png)\r\n\r\n```c\r\n哈希算法：\r\n	Redis计算哈希值和索引值的方法如下：\r\n	1.使用字典设置的哈希函数，计算键key的哈希值\r\n	hash = dict->type->hashFunction(key);\r\n	2.使用哈希表的sizemask属性和哈希值，计算出索引值\r\n	根据情况不同，x可以是0或者1\r\n	index = hash & dict->ht[x].sizemask;\r\n举例如下：\r\n```\r\n\r\n![1573212877806](C:\\Users\\sanshi\\AppData\\Roaming\\Typora\\typora-user-images\\1573212877806.png)\r\n\r\n```c\r\nRedis数据库哈希算法：\r\n	当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，而且算法的速度也非常快。\r\n```\r\n\r\n```c\r\nRedis解决键冲突：\r\n	当有两个或者以上数量的键被分配到哈希表数组的同一个索引上面时，我们称这些键发生了冲突(collision)。\r\n	Redis使用链地址法(separate chaining)来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。\r\n	举个例子：\r\n```\r\n\r\n![1573213353986](C:\\Users\\sanshi\\AppData\\Roaming\\Typora\\typora-user-images\\1573213353986.png)', '2020-05-01 19:37:17', '2020-05-01 19:37:33');
INSERT INTO `t_article` VALUES (6, 'mysql高性能', '结构', 'input {\r\n  jdbc {\r\n    jdbc_driver_library => \"D:\\ELK\\logstash-6.0.0\\mysql-connector-java-8.0.19.jar\"\r\n    jdbc_driver_class => \"com.mysql.cj.jdbc.Driver\"\r\n    jdbc_connection_string => \"jdbc:mysql://localhost:3306/es_blog?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC\"\r\n    jdbc_user => \"root\"\r\n    jdbc_password => \"1234567890\"\r\n    statement => \"SELECT id, title, author, content FROM t_article where update_time > :sql_last_value\"\r\n    jdbc_paging_enabled => \"true\"\r\n    jdbc_page_size => \"50000\"\r\n    schedule => \"* * * * *\"\r\n  }\r\n}\r\n\r\nfilter {\r\n   json {\r\n        source => \"message\"\r\n        remove_field => [\"message\"]\r\n    }\r\n}\r\n\r\noutput {\r\n  stdout {\r\n    codec => rubydebug\r\n  }\r\n  elasticsearch {\r\n    hosts => \"127.0.0.1:9200\"\r\n    index => \"logstash-blog\"\r\n    document_id => \"%{id}\"\r\n    document_type => \"article\"\r\n  }        \r\n} ', '2020-05-01 20:00:19', '2020-05-01 20:00:19');
INSERT INTO `t_article` VALUES (7, '最重要的查询', '三石', '虽然 Elasticsearch 自带了很多的查询，但经常用到的也就那么几个。我们将在 深入搜索 章节详细讨论那些查询的细节，接下来我们对最重要的几个查询进行简单介绍。\r\n\r\nmatch_all 查询\r\nmatch_all 查询简单的匹配所有文档。在没有指定查询方式时，它是默认的查询：\r\n\r\n{ \"match_all\": {}}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n它经常与 filter 结合使用—​例如，检索收件箱里的所有邮件。所有邮件被认为具有相同的相关性，所以都将获得分值为 1 的中性 _score。\r\n\r\nmatch 查询\r\n无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。\r\n\r\n如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串：\r\n\r\n{ \"match\": { \"tweet\": \"About Search\" }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n如果在一个精确值的字段上使用它，例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值：\r\n\r\n{ \"match\": { \"age\":    26           }}\r\n{ \"match\": { \"date\":   \"2014-09-01\" }}\r\n{ \"match\": { \"public\": true         }}\r\n{ \"match\": { \"tag\":    \"full_text\"  }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n对于精确值的查询，你可能需要使用 filter 语句来取代 query，因为 filter 将会被缓存。接下来，我们将看到一些关于 filter 的例子。\r\n\r\n不像我们在 轻量 搜索 章节介绍的字符串查询（query-string search）， match 查询不使用类似 +user_id:2 +tweet:search 的查询语法。它只是去查找给定的单词。这就意味着将查询字段暴露给你的用户是安全的；你需要控制那些允许被查询字段，不易于抛出语法异常。\r\n\r\nmulti_match 查询\r\nmulti_match 查询可以在多个字段上执行相同的 match 查询：\r\n\r\n{\r\n    \"multi_match\": {\r\n        \"query\":    \"full text search\",\r\n        \"fields\":   [ \"title\", \"body\" ]\r\n    }\r\n}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\nrange 查询\r\nrange 查询找出那些落在指定区间内的数字或者时间：\r\n\r\n{\r\n    \"range\": {\r\n        \"age\": {\r\n            \"gte\":  20,\r\n            \"lt\":   30\r\n        }\r\n    }\r\n}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n被允许的操作符如下：\r\n\r\ngt\r\n大于\r\ngte\r\n大于等于\r\nlt\r\n小于\r\nlte\r\n小于等于\r\nterm 查询\r\nterm 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串：\r\n\r\n{ \"term\": { \"age\":    26           }}\r\n{ \"term\": { \"date\":   \"2014-09-01\" }}\r\n{ \"term\": { \"public\": true         }}\r\n{ \"term\": { \"tag\":    \"full_text\"  }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\nterm 查询对于输入的文本不 分析 ，所以它将给定的值进行精确查询。\r\n\r\nterms 查询\r\nterms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：\r\n\r\n{ \"terms\": { \"tag\": [ \"search\", \"full_text\", \"nosql\" ] }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n和 term 查询一样，terms 查询对于输入的文本不分析。它查询那些精确匹配的值（包括在大小写、重音、空格等方面的差异）。\r\n\r\nexists 查询和 missing 查询\r\nexists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性：\r\n\r\n虽然 Elasticsearch 自带了很多的查询，但经常用到的也就那么几个。我们将在 深入搜索 章节详细讨论那些查询的细节，接下来我们对最重要的几个查询进行简单介绍。\r\n\r\nmatch_all 查询\r\nmatch_all 查询简单的匹配所有文档。在没有指定查询方式时，它是默认的查询：\r\n\r\n{ \"match_all\": {}}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n它经常与 filter 结合使用—​例如，检索收件箱里的所有邮件。所有邮件被认为具有相同的相关性，所以都将获得分值为 1 的中性 _score。\r\n\r\nmatch 查询\r\n无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。\r\n\r\n如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串：\r\n\r\n{ \"match\": { \"tweet\": \"About Search\" }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n如果在一个精确值的字段上使用它，例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值：\r\n\r\n{ \"match\": { \"age\":    26           }}\r\n{ \"match\": { \"date\":   \"2014-09-01\" }}\r\n{ \"match\": { \"public\": true         }}\r\n{ \"match\": { \"tag\":    \"full_text\"  }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n对于精确值的查询，你可能需要使用 filter 语句来取代 query，因为 filter 将会被缓存。接下来，我们将看到一些关于 filter 的例子。\r\n\r\n不像我们在 轻量 搜索 章节介绍的字符串查询（query-string search）， match 查询不使用类似 +user_id:2 +tweet:search 的查询语法。它只是去查找给定的单词。这就意味着将查询字段暴露给你的用户是安全的；你需要控制那些允许被查询字段，不易于抛出语法异常。\r\n\r\nmulti_match 查询\r\nmulti_match 查询可以在多个字段上执行相同的 match 查询：\r\n\r\n{\r\n    \"multi_match\": {\r\n        \"query\":    \"full text search\",\r\n        \"fields\":   [ \"title\", \"body\" ]\r\n    }\r\n}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\nrange 查询\r\nrange 查询找出那些落在指定区间内的数字或者时间：\r\n\r\n{\r\n    \"range\": {\r\n        \"age\": {\r\n            \"gte\":  20,\r\n            \"lt\":   30\r\n        }\r\n    }\r\n}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n被允许的操作符如下：\r\n\r\ngt\r\n大于\r\ngte\r\n大于等于\r\nlt\r\n小于\r\nlte\r\n小于等于\r\nterm 查询\r\nterm 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串：\r\n\r\n{ \"term\": { \"age\":    26           }}\r\n{ \"term\": { \"date\":   \"2014-09-01\" }}\r\n{ \"term\": { \"public\": true         }}\r\n{ \"term\": { \"tag\":    \"full_text\"  }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\nterm 查询对于输入的文本不 分析 ，所以它将给定的值进行精确查询。\r\n\r\nterms 查询\r\nterms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：\r\n\r\n{ \"terms\": { \"tag\": [ \"search\", \"full_text\", \"nosql\" ] }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n和 term 查询一样，terms 查询对于输入的文本不分析。它查询那些精确匹配的值（包括在大小写、重音、空格等方面的差异）。\r\n\r\nexists 查询和 missing 查询\r\nexists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性：\r\n\r\n虽然 Elasticsearch 自带了很多的查询，但经常用到的也就那么几个。我们将在 深入搜索 章节详细讨论那些查询的细节，接下来我们对最重要的几个查询进行简单介绍。\r\n\r\nmatch_all 查询\r\nmatch_all 查询简单的匹配所有文档。在没有指定查询方式时，它是默认的查询：\r\n\r\n{ \"match_all\": {}}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n它经常与 filter 结合使用—​例如，检索收件箱里的所有邮件。所有邮件被认为具有相同的相关性，所以都将获得分值为 1 的中性 _score。\r\n\r\nmatch 查询\r\n无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。\r\n\r\n如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串：\r\n\r\n{ \"match\": { \"tweet\": \"About Search\" }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n如果在一个精确值的字段上使用它，例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值：\r\n\r\n{ \"match\": { \"age\":    26           }}\r\n{ \"match\": { \"date\":   \"2014-09-01\" }}\r\n{ \"match\": { \"public\": true         }}\r\n{ \"match\": { \"tag\":    \"full_text\"  }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n对于精确值的查询，你可能需要使用 filter 语句来取代 query，因为 filter 将会被缓存。接下来，我们将看到一些关于 filter 的例子。\r\n\r\n不像我们在 轻量 搜索 章节介绍的字符串查询（query-string search）， match 查询不使用类似 +user_id:2 +tweet:search 的查询语法。它只是去查找给定的单词。这就意味着将查询字段暴露给你的用户是安全的；你需要控制那些允许被查询字段，不易于抛出语法异常。\r\n\r\nmulti_match 查询\r\nmulti_match 查询可以在多个字段上执行相同的 match 查询：\r\n\r\n{\r\n    \"multi_match\": {\r\n        \"query\":    \"full text search\",\r\n        \"fields\":   [ \"title\", \"body\" ]\r\n    }\r\n}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\nrange 查询\r\nrange 查询找出那些落在指定区间内的数字或者时间：\r\n\r\n{\r\n    \"range\": {\r\n        \"age\": {\r\n            \"gte\":  20,\r\n            \"lt\":   30\r\n        }\r\n    }\r\n}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n被允许的操作符如下：\r\n\r\ngt\r\n大于\r\ngte\r\n大于等于\r\nlt\r\n小于\r\nlte\r\n小于等于\r\nterm 查询\r\nterm 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串：\r\n\r\n{ \"term\": { \"age\":    26           }}\r\n{ \"term\": { \"date\":   \"2014-09-01\" }}\r\n{ \"term\": { \"public\": true         }}\r\n{ \"term\": { \"tag\":    \"full_text\"  }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\nterm 查询对于输入的文本不 分析 ，所以它将给定的值进行精确查询。\r\n\r\nterms 查询\r\nterms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：\r\n\r\n{ \"terms\": { \"tag\": [ \"search\", \"full_text\", \"nosql\" ] }}\r\n拷贝为 cURL\r\n在 Sense 中查看\r\n \r\n和 term 查询一样，terms 查询对于输入的文本不分析。它查询那些精确匹配的值（包括在大小写、重音、空格等方面的差异）。\r\n\r\nexists 查询和 missing 查询\r\nexists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性：\r\n\r\n', '2020-05-01 20:24:15', '2020-05-01 20:24:15');
INSERT INTO `t_article` VALUES (8, '大傻逼', '煞笔', '我就是个大傻逼，无论你说什么，如果你这么说，只能说你是一个巨傻逼哈哈哈我就是个大傻逼，无论你说什么，如果你这么说，只能说你是一个巨傻逼哈哈哈我就是个大傻逼，无论你说什么，如果你这么说，只能说你是一个巨傻逼哈哈哈我就是个大傻逼，无论你说什么，如果你这么说，只能说你是一个巨傻逼哈哈哈', '2020-05-02 22:40:28', '2020-05-02 22:40:28');
INSERT INTO `t_article` VALUES (9, 'springboot启动日志', '铁憨憨', 'Connected to the target VM, address: \'127.0.0.1:57400\', transport: \'socket\'22:43:51.940 [main] INFO com.sanshi.searchforblog.SearchForBlogApplication - 是否有日志？22:43:52.600 [restartedMain] INFO com.sanshi.searchforblog.SearchForBlogApplication - 是否有日志？DEBUG StatusLogger org.slf4j.helpers.Log4jLoggerFactory is not on classpath. Good!2020-05-02 22:43:53.981 DEBUG 6444 --- [  restartedMain] .c.l.ClasspathLoggingApplicationListener : Application started with classpath: [file:/D:/ideaProjects/search-for-blog/target/classes/]2020-05-02 22:43:54.330  INFO 6444 --- [  restartedMain] c.s.s.SearchForBlogApplication           : Starting t.SpringApplication               : Loading source class com.sanshi.searchforblog.SearchForBlogApplication2020-05-02 22:43:54.481 DEBUG 6444 --- [  restartedMain] o.s.b.c.c.ConfigFileApplicationListener  : Activated activeProfiles application.yml2020-05-02 22:43:54.482 DEBUG 6444 --- [  restartedMain] o.s.b.c.c.ConfigFileApplicationListener  : Loaded config file \'file:/D:/ideaProjects/search-for-blog/target/classes/application.yml\' (classpath:/application.yml)2020-05-02 22:43:54.485 DEBUG 6444 --- [  restartedMain] o.s.b.devtools.restart.ChangeableUrls    : Matching URLs for reloading : [file:/D:/ideaProjects/search-for-blog/target/classes/]2020-05-02 22:43:54.485 DEBUG 6444 --- [  restartedMain] o.s.b.d.settings.DevToolsSettings        : Included patterns for restart : []2020-05-02 22:43:54.486 DEBUG 6444 --- [  restartedMain] o.s.b.d.settings.DevToolsSettings        : Excluded patterns for restart : [/spring-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/, /spring-boot/target/classes/, /spring-boot-starter--]+/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter/target/classes/]2020-05-02 22:43:54.486  INFO 6444 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set \'spring.devtools.add-properties\' to \'false\' to disable2020-05-02 22:43:54.486  INFO 6444 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the \'logging.level.web\' property to \'DEBUG\'2020-05-02 22:43:54.486 DEBUG 6444 --- [  restartedMain] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@255ba8b72020-05-02 22:43:56.514 DEBUG 6444 --- [  restartedMain] o.s.b.a.AutoConfigurationPackages        : @EnableAutoConfiguration was declared on a class in the package \'com.sanshi.searchforblog\'. Automatic @Repository and @Entity scanning is enabled.2020-05-02 22:43:56.769  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Elasticsearch repositories in DEFAULT mode.2020-05-02 22:43:56.802  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 24ms. Found 0 Elasticsearch repository interfaces.2020-05-02 22:43:56.816  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Reactive Elasticsearch repositories in DEFAULT mode.2020-05-02 22:43:56.825  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 7ms. 2020-05-02 22:43:58.553 DEBUG 6444 --- [  restartedMain] .s.b.w.e.t.TomcatServletWebServerFactory : None of the document roots [src/main/webapp, public, static] point to a directory and will be ignored.2020-05-02 22:43:58.926  INFO 6444 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)2020-05-02 22:43:58.985  INFO 6444 --- [  restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]2020-05-02 22:43:58.986  INFO 6444 --- [  restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.33]2020-05-02 22:44:03.131  INFO 6444 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path \'\'2020-05-02 22:44:03.140  INFO 6444 --- [  restartedMain] c.s.s.SearchForBlogApplication           : Started SearchForBlogApplication in 10.516 seconds (JVM running for 13.83)2020-05-02 22:44:03.146 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Creating new Restarter for thread Thread[main,5,main]2020-05-02 22:44:03.147 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Immediately restarting application2020-05-02 22:44:03.148 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Created RestartClassLoader org.springframework.boot.devtools.restart.classloader.RestartClassLoader@105d2bac2020-05-02 22:44:03.148 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Starting application com.sanshi.searchforblog.SearchForBlogApplication with URLs [file:/D:/ideaProjects/search-for-blog/target/classes/]', '2020-05-02 22:48:08', '2020-05-02 22:48:08');
INSERT INTO `t_article` VALUES (10, '启动日志', '铁憨憨', 'Connected to the target VM, address: \'127.0.0.1:57400\', transport: \'socket\'22:43:51.940 [main] INFO com.sanshi.searchforblog.SearchForBlogApplication - 是否有日志？22:43:52.600 [restartedMain] INFO com.sanshi.searchforblog.SearchForBlogApplication - 是否有日志？DEBUG StatusLogger org.slf4j.helpers.Log4jLoggerFactory is not on classpath. Good!2020-05-02 22:43:53.981 DEBUG 6444 --- [  restartedMain] .c.l.ClasspathLoggingApplicationListener : Application started with classpath: [file:/D:/ideaProjects/search-for-blog/target/classes/]2020-05-02 22:43:54.330  INFO 6444 --- [  restartedMain] c.s.s.SearchForBlogApplication           : Starting t.SpringApplication               : Loading source class com.sanshi.searchforblog.SearchForBlogApplication2020-05-02 22:43:54.481 DEBUG 6444 --- [  restartedMain] o.s.b.c.c.ConfigFileApplicationListener  : Activated activeProfiles application.yml2020-05-02 22:43:54.482 DEBUG 6444 --- [  restartedMain] o.s.b.c.c.ConfigFileApplicationListener  : Loaded config file \'file:/D:/ideaProjects/search-for-blog/target/classes/application.yml\' (classpath:/application.yml)2020-05-02 22:43:54.485 DEBUG 6444 --- [  restartedMain] o.s.b.devtools.restart.ChangeableUrls    : Matching URLs for reloading : [file:/D:/ideaProjects/search-for-blog/target/classes/]2020-05-02 22:43:54.485 DEBUG 6444 --- [  restartedMain] o.s.b.d.settings.DevToolsSettings        : Included patterns for restart : []2020-05-02 22:43:54.486 DEBUG 6444 --- [  restartedMain] o.s.b.d.settings.DevToolsSettings        : Excluded patterns for restart : [/spring-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/, /spring-boot/target/classes/, /spring-boot-starter--]+/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter/target/classes/]2020-05-02 22:43:54.486  INFO 6444 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set \'spring.devtools.add-properties\' to \'false\' to disable2020-05-02 22:43:54.486  INFO 6444 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the \'logging.level.web\' property to \'DEBUG\'2020-05-02 22:43:54.486 DEBUG 6444 --- [  restartedMain] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@255ba8b72020-05-02 22:43:56.514 DEBUG 6444 --- [  restartedMain] o.s.b.a.AutoConfigurationPackages        : @EnableAutoConfiguration was declared on a class in the package \'com.sanshi.searchforblog\'. Automatic @Repository and @Entity scanning is enabled.2020-05-02 22:43:56.769  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Elasticsearch repositories in DEFAULT mode.2020-05-02 22:43:56.802  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 24ms. Found 0 Elasticsearch repository interfaces.2020-05-02 22:43:56.816  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Reactive Elasticsearch repositories in DEFAULT mode.2020-05-02 22:43:56.825  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 7ms. 2020-05-02 22:43:58.553 DEBUG 6444 --- [  restartedMain] .s.b.w.e.t.TomcatServletWebServerFactory : None of the document roots [src/main/webapp, public, static] point to a directory and will be ignored.2020-05-02 22:43:58.926  INFO 6444 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)2020-05-02 22:43:58.985  INFO 6444 --- [  restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]2020-05-02 22:43:58.986  INFO 6444 --- [  restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.33]2020-05-02 22:44:03.131  INFO 6444 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path \'\'2020-05-02 22:44:03.140  INFO 6444 --- [  restartedMain] c.s.s.SearchForBlogApplication           : Started SearchForBlogApplication in 10.516 seconds (JVM running for 13.83)2020-05-02 22:44:03.146 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Creating new Restarter for thread Thread[main,5,main]2020-05-02 22:44:03.147 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Immediately restarting application2020-05-02 22:44:03.148 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Created RestartClassLoader org.springframework.boot.devtools.restart.classloader.RestartClassLoader@105d2bac2020-05-02 22:44:03.148 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Starting application com.sanshi.searchforblog.SearchForBlogApplication with URLs [file:/D:/ideaProjects/search-for-blog/target/classes/]', '2020-05-02 22:50:38', '2020-05-02 22:50:38');
INSERT INTO `t_article` VALUES (11, '启动日志', '铁憨憨', 'Connected to the target VM, address: \'127.0.0.1:57400\', transport: \'socket\'22:43:51.940 [main] INFO com.sanshi.searchforblog.SearchForBlogApplication - 是否有日志？22:43:52.600 [restartedMain] INFO com.sanshi.searchforblog.SearchForBlogApplication - 是否有日志？DEBUG StatusLogger org.slf4j.helpers.Log4jLoggerFactory is not on classpath. Good!2020-05-02 22:43:53.981 DEBUG 6444 --- [  restartedMain] .c.l.ClasspathLoggingApplicationListener : Application started with classpath: [file:/D:/ideaProjects/search-for-blog/target/classes/]2020-05-02 22:43:54.330  INFO 6444 --- [  restartedMain] c.s.s.SearchForBlogApplication           : Starting t.SpringApplication               : Loading source class com.sanshi.searchforblog.SearchForBlogApplication2020-05-02 22:43:54.481 DEBUG 6444 --- [  restartedMain] o.s.b.c.c.ConfigFileApplicationListener  : Activated activeProfiles application.yml2020-05-02 22:43:54.482 DEBUG 6444 --- [  restartedMain] o.s.b.c.c.ConfigFileApplicationListener  : Loaded config file \'file:/D:/ideaProjects/search-for-blog/target/classes/application.yml\' (classpath:/application.yml)2020-05-02 22:43:54.485 DEBUG 6444 --- [  restartedMain] o.s.b.devtools.restart.ChangeableUrls    : Matching URLs for reloading : [file:/D:/ideaProjects/search-for-blog/target/classes/]2020-05-02 22:43:54.485 DEBUG 6444 --- [  restartedMain] o.s.b.d.settings.DevToolsSettings        : Included patterns for restart : []2020-05-02 22:43:54.486 DEBUG 6444 --- [  restartedMain] o.s.b.d.settings.DevToolsSettings        : Excluded patterns for restart : [/spring-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/, /spring-boot/target/classes/, /spring-boot-starter--]+/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter/target/classes/]2020-05-02 22:43:54.486  INFO 6444 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set \'spring.devtools.add-properties\' to \'false\' to disable2020-05-02 22:43:54.486  INFO 6444 --- [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the \'logging.level.web\' property to \'DEBUG\'2020-05-02 22:43:54.486 DEBUG 6444 --- [  restartedMain] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@255ba8b72020-05-02 22:43:56.514 DEBUG 6444 --- [  restartedMain] o.s.b.a.AutoConfigurationPackages        : @EnableAutoConfiguration was declared on a class in the package \'com.sanshi.searchforblog\'. Automatic @Repository and @Entity scanning is enabled.2020-05-02 22:43:56.769  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Elasticsearch repositories in DEFAULT mode.2020-05-02 22:43:56.802  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 24ms. Found 0 Elasticsearch repository interfaces.2020-05-02 22:43:56.816  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Reactive Elasticsearch repositories in DEFAULT mode.2020-05-02 22:43:56.825  INFO 6444 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 7ms. 2020-05-02 22:43:58.553 DEBUG 6444 --- [  restartedMain] .s.b.w.e.t.TomcatServletWebServerFactory : None of the document roots [src/main/webapp, public, static] point to a directory and will be ignored.2020-05-02 22:43:58.926  INFO 6444 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)2020-05-02 22:43:58.985  INFO 6444 --- [  restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]2020-05-02 22:43:58.986  INFO 6444 --- [  restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.33]2020-05-02 22:44:03.131  INFO 6444 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path \'\'2020-05-02 22:44:03.140  INFO 6444 --- [  restartedMain] c.s.s.SearchForBlogApplication           : Started SearchForBlogApplication in 10.516 seconds (JVM running for 13.83)2020-05-02 22:44:03.146 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Creating new Restarter for thread Thread[main,5,main]2020-05-02 22:44:03.147 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Immediately restarting application2020-05-02 22:44:03.148 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Created RestartClassLoader org.springframework.boot.devtools.restart.classloader.RestartClassLoader@105d2bac2020-05-02 22:44:03.148 DEBUG 6444 --- [  restartedMain] o.s.boot.devtools.restart.Restarter      : Starting application com.sanshi.searchforblog.SearchForBlogApplication with URLs [file:/D:/ideaProjects/search-for-blog/target/classes/]', '2020-05-02 22:58:27', '2020-05-02 22:58:27');
INSERT INTO `t_article` VALUES (12, '为什么', '李迪', '为什么，为什么，这到底是为什么？我也太难了，你都不爱我！', '2020-05-02 23:35:15', '2020-05-02 23:35:15');
INSERT INTO `t_article` VALUES (13, '臭臭的', '李迪', '你臭臭的，真好吃！', '2020-05-02 23:40:31', '2020-05-02 23:40:31');

SET FOREIGN_KEY_CHECKS = 1;
